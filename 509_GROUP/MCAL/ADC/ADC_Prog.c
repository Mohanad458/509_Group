/*
 * ADC_Prog.c
 *
 *  Created on: Sep 13, 2022
 *      Author: Mohanad
 */
#include "ADC_Interface.h"
#include "ADC_Private.h"

void M_ADC_Void_ADCInit(void)
{
	//to select vref -> avcc
	CLR_BIT(ADMUX_REG,REFS1_BIT);
	SET_BIT(ADMUX_REG,REFS0_BIT);

	//to select right adjust
	CLR_BIT(ADMUX_REG,ADLAR_BIT);
	CLR_BIT(ADMUX_REG,MUX4_BIT);
	CLR_BIT(ADMUX_REG,MUX3_BIT);
	CLR_BIT(ADMUX_REG,MUX2_BIT);
	CLR_BIT(ADMUX_REG,MUX1_BIT);
	SET_BIT(ADMUX_REG,MUX0_BIT);

	//to set division factor 128
	SET_BIT(ADCSRA_REG,ADPS2_BIT);
	SET_BIT(ADCSRA_REG,ADPS1_BIT);
	SET_BIT(ADCSRA_REG,ADPS0_BIT);
	//to start conversion
	SET_BIT(ADCSRA_REG,ADEN_BIT);
	//to enable adc circuit
	SET_BIT(ADCSRA_REG,ADSC_BIT);

}
u16  M_ADC_Void_ADCRead(u8 Copy_U8_AdcChannel)
{
	u32 Local_U32_Counter=0;
	switch(Copy_U8_AdcChannel)
	{
	case ADC_CHANNEL_0:
		CLR_BIT(ADMUX_REG,MUX4_BIT);
		CLR_BIT(ADMUX_REG,MUX3_BIT);
		CLR_BIT(ADMUX_REG,MUX2_BIT);
		CLR_BIT(ADMUX_REG,MUX1_BIT);
		CLR_BIT(ADMUX_REG,MUX0_BIT);
		break;
	case ADC_CHANNEL_1:
		CLR_BIT(ADMUX_REG,MUX4_BIT);
		CLR_BIT(ADMUX_REG,MUX3_BIT);
		CLR_BIT(ADMUX_REG,MUX2_BIT);
		CLR_BIT(ADMUX_REG,MUX1_BIT);
		SET_BIT(ADMUX_REG,MUX0_BIT);
		break;
	case ADC_CHANNEL_2:
		CLR_BIT(ADMUX_REG,MUX4_BIT);
		CLR_BIT(ADMUX_REG,MUX3_BIT);
		CLR_BIT(ADMUX_REG,MUX2_BIT);
		SET_BIT(ADMUX_REG,MUX1_BIT);
		CLR_BIT(ADMUX_REG,MUX0_BIT);
		break;
	case ADC_CHANNEL_3:
		CLR_BIT(ADMUX_REG,MUX4_BIT);
		CLR_BIT(ADMUX_REG,MUX3_BIT);
		CLR_BIT(ADMUX_REG,MUX2_BIT);
		SET_BIT(ADMUX_REG,MUX1_BIT);
		SET_BIT(ADMUX_REG,MUX0_BIT);
		break;
	default:  break;
	}
	/* TO START CONVERTION */
	SET_BIT(ADCSRA_REG,ADSC_BIT);
	//while(GET_BIT(ADCSRA_REG,ADIF_BIT) == ADC_STILL_CONVERT);
	while(Local_U32_Counter < POLLING_TIME)
	{
		Local_U32_Counter++;
		if(GET_BIT(ADCSRA_REG,ADIF_BIT) == ADC_CONERSION_COMPLETE)
		{
			break;
	    }
	}
	return ADCL_REG;
}







